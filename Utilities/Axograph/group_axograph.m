function [time, datagroups, group] = group_axograph(S);

% [time, datagroups, group] = group_axograph(S);
% 
% Separate AxoGraph data into GROUPS by unique groupnames.
% S must be a struct generated by passing an AxoGraph file to read_axograph().
%     S must contain exactly one (1) time column, denoted by the field S.timeGroup
%     (i.e., sum(S.timeGroup) must equal 1)
% TIME is a double array containing time sample points (units = sec).
% DATAGROUPS is a double array of indices into the original struct field S.groupNames.
% GROUP is a cell array containing the sweeps organized by "groups" (i.e., each unique column name is a separate group).
%     Each element of 'group' is a double array containing all the sweeps in that group.
%     Each individual trace can be accessed by calling 'group{group#}(rowindx, colindx)'.
%     NOTE THE USE OF {} TO INDEX THE CELL ELEMENT, BUT USE OF () TO INDEX THE DOUBLE ARRAY.
%     For example, these two statements are equivalent, and yield ALL columns from group #1.
%         x = group{1}
%         x = group{1}(:,:)
%     In contrast, this statement yields only columns #3,5 and 7 from group #1:
%         x = group{1}(:,[3,5,7])
%     This statement yields only ROWS 1-10 from group #1:
%         x = group{1}(1:10, :)
%     etc...
% 
% MattJones, 2007




if sum(S.timeGroup) == 1                            % If there is only one unique group holding 'Time (s)'
    time = S.columnData{S.timeGroup( S.timeGroup )};	% Then put that group into the double array "time"
    datagroups = find(~S.timeGroup);                % Find the ones that *aren't* the time array
    
    group = {};                                 % Initialize the cell array to hold the separate groups
    for n = 1:length(datagroups)                % Loop through the data groups
        g = find( S.groupID==datagroups(n) );   % Find all the traces that match the current data groupID
        group{n} = cat( 2, S.columnData{ g } ); % Concatenate these traces together and store in the cell array "group"
    end
end

